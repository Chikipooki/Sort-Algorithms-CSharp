# Алгоритмы сортировки / Sort Algorithms
## Описание / Description

### Сортировка пузырьком (Bubble Sort)
Выполняется некоторое количество проходов по массиву - начиная от начала массива перебираются пары соседних элементов. Если первый больше второго, элементы меняются местами.

|Временная сложность:| |Пространственная сложность:| |
|-|-|-|-|
|Лучшее: |$O(n$) |Всего:|$O(1)$| 
|Среднее:|$O(n^2$)|Дополнительно:| |
|Худшее: |$O(n^2$)| | |

### Шейкерная/коктейльная сортировка (Shaker/Cocktail Sort)
Алгоритм расширяет пузырьковую сортировку, работая в двух направлениях.

|Временная сложность:| |Пространственная сложность:| |
|-|-|-|-|
|Лучшее: |$O(n$) |Всего:|$O(1)$| 
|Среднее:|$O(n^2$)|Дополнительно:| |
|Худшее: |$O(n^2$)| | |

### Сортировка вставками (Insertion Sort)
Суть его заключается в том что, на каждом шаге алгоритма мы берем один из элементов массива, находим позицию для вставки и вставляем.

|Временная сложность:| |Пространственная сложность:| |
|-|-|-|-|
|Лучшее: |$O(n$) |Всего:|$O(n)$| 
|Среднее:|$O(n^2$)|Дополнительно:|$O(1)$|
|Худшее: |$O(n^2$)| | |

### Сортировка Шелла (Shell Sort)
Алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга.

|Временная сложность:| |Пространственная сложность:| |
|-|-|-|-|
|Лучшее: |$O(n$ $log$ $n$) |Всего:|$O(n)$| 
|Среднее:|Зависит от выбранных шагов|Дополнительно:|$O(1)$|
|Худшее: |$O(n^2$)| | |

### Сортировка деревом (Tree Sort)
 Универсальный алгоритм сортировки, заключающийся в построении двоичного дерева поиска по ключам массива (списка), с последующей сборкой результирующего массива путём обхода узлов построенного дерева в необходимом порядке следования ключей. Данная сортировка является оптимальной при получении данных путём непосредственного чтения из потока (например, файла, сокета или консоли).

|Временная сложность:| |Пространственная сложность:| |
|-|-|-|-|
|Лучшее: |$O(n$ $log$ $n$) |Всего:|$O(n)$| 
|Среднее:|$O(n$ $log$ $n$)|Дополнительно:||
|Худшее: |$O(n^2$)| | |


## Сложность алгоритмов / Algorithm complexity

<b>Сложность алгоритмов</b>  обычно оценивают по времени выполнения или по используемой памяти. В обоих случаях сложность зависит от размеров входных данных: массив из 100 элементов будет обработан быстрее, чем аналогичный из 1000. 

<b>Пространственнуюсложность</b>  оценивают по объему памяти, необходимый программе для её выполнения.

### O(1) — константная сложность
Случается, что время работы алгоритма вообще не зависит от размера входных данных. Тогда сложность обозначают как O(1). Например, для определения значения третьего элемента массива не нужно ни запоминать элементы, ни проходить по ним сколько-то раз. Всегда нужно просто дождаться в потоке входных данных третий элемент и это будет результатом, на вычисление которого для любого количества данных нужно одно и то же время.

### O(n) — линейная сложность
Такой сложностью обладает, например, алгоритм поиска наибольшего элемента в не отсортированном массиве. Нам придется пройтись по всем n элементам массива, чтобы понять, какой из них максимальный.

### O(log n) — логарифмическая сложность
Простейший пример — бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в н ем какое-то конкретное значение, методом деления пополам. Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину. И так будем продолжать делить пополам, в итоге проверим log n элементов.

### O(n^2) — квадратичная сложность
Такую сложность имеет, например, алгоритм сортировки вставками. В канонической реализации он представляет из себя два вложенных цикла: один, чтобы проходить по всему массиву, а второй, чтобы находить место очередному элементу в уже отсортированной части. Таким образом, количество операций будет зависеть от размера массива как n * n, т. е. n2.

<!--## Приложение / App
--------------------------->
<!--Gif-->
<!--![Alt Text]()-->
