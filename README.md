# Алгоритмы сортировки / Sort Algorithms
## Описание / Description

### Сортировка пузырьком (Bubble Sort)
Выполняется некоторое количество проходов по массиву - начиная от начала массива перебираются пары соседних элементов. Если первый больше второго, элементы меняются местами.

#### Временная сложность:
Лучшиее O(n), Среднее O(n^2), худшее  O(n^2)
#### Пространственная сложность: O(1)


## Сложожность алгоритмов / Algorithm complexity

<b>Сложность алгоритмов</b>  обычно оценивают по времени выполнения или по используемой памяти. В обоих случаях сложность зависит от размеров входных данных: массив из 100 элементов будет обработан быстрее, чем аналогичный из 1000. 

<b>Пространственнуюсложность</b>  оценивают по объему памяти, необходимый программе для её выполнения.

### O(1) — константная сложность
Случается, что время работы алгоритма вообще не зависит от размера входных данных. Тогда сложность обозначают как O(1). Например, для определения значения третьего элемента массива не нужно ни запоминать элементы, ни проходить по ним сколько-то раз. Всегда нужно просто дождаться в потоке входных данных третий элемент и это будет результатом, на вычисление которого для любого количества данных нужно одно и то же время.

### O(n) — линейная сложность
Такой сложностью обладает, например, алгоритм поиска наибольшего элемента в не отсортированном массиве. Нам придется пройтись по всем n элементам массива, чтобы понять, какой из них максимальный.

### O(log n) — логарифмическая сложность
Простейший пример — бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в н ем какое-то конкретное значение, методом деления пополам. Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину. И так будем продолжать делить пополам, в итоге проверим log n элементов.

### O(n^2) — квадратичная сложность
Такую сложность имеет, например, алгоритм сортировки вставками. В канонической реализации он представляет из себя два вложенных цикла: один, чтобы проходить по всему массиву, а второй, чтобы находить место очередному элементу в уже отсортированной части. Таким образом, количество операций будет зависеть от размера массива как n * n, т. е. n2.

<!--## Приложение / App
--------------------------->
<!--Gif-->
<!--![Alt Text]()-->
